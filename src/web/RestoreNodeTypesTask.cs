// <autogenerated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Text;

public class RestoreNodeTypesTask : Microsoft.Build.Utilities.Task
{
    public string FolderNames { get; set; }
    public string PatchDependencies { get; set; } = "true";

    public bool Success = true;

    public override bool Execute()
    {
        try
        {
            var skipPackageJsonKeys = new HashSet<string>
                {
                    "bundledDependencies",
                    "dependencies",
                    "devDependencies",
                    "engines",
                    "files",
                    "keywords",
                    "optionalDependencies",
                    "overrides",
                    "peerDependencies",
                    "peerDependenciesMeta",
                    "scripts",
                    "version"
                };

            var newDeps = new SortedDictionary<string, string>();
            foreach (var pkgFolder in (FolderNames ?? "")
                .Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries))
            {
                var pkgPath = Path.Combine("node_modules", ".dotnet", pkgFolder);

                Directory.CreateDirectory(pkgPath);

                var pkgFile = Path.Combine(pkgPath, "package.json");
                var dotFile = Path.Combine(pkgPath, "package.dotnet.json");
                OrderedDictionary pkgJson;

                var pkgId = pkgFolder.ToLowerInvariant();
                var idx = pkgId.IndexOf('.');
                if (idx > 0)
                {
                    var company = pkgId.Substring(0, idx);
                    if (company == "serenity")
                        company = "serenity-is";
                    pkgId = "@" + company + "/" + pkgId.Substring(idx + 1);
                }

                OrderedDictionary dotJson = null;
                if (File.Exists(dotFile))
                {
                    try
                    {
                        dotJson = new JsonParser(File.ReadAllText(dotFile).Trim()).ParseObject();
                        if (dotJson.Contains("name") && dotJson["name"] != null)
                            pkgId = dotJson["name"].ToString();
                    }
                    catch (Exception ex1)
                    {
                        Log.LogWarning("Error during parsing RestoreNodeTypesTask: " +
                            dotFile + " " +
                            ex1.ToString());
                        dotJson = null;
                    }
                }

                if (dotJson != null)
                {
                    pkgJson = new OrderedDictionary()
                    {
                        ["name"] = pkgId
                    };

                    foreach (string key in dotJson.Keys)
                        if (!skipPackageJsonKeys.Contains(key))
                            pkgJson[key] = dotJson[key];
                }
                else
                {
                    var exports = new OrderedDictionary()
                    {
                        ["."] = new OrderedDictionary()
                        {
                            ["types"] = "./dist/index.d.ts",
                            ["import"] = "./dist/index.js"
                        },
                        ["./dist/*.css"] = "./dist/*.css"
                    };

                    if (pkgId == "@serenity-is/domwise")
                    {
                        exports["./jsx-runtime"] = "./dist/jsx-runtime.js";
                        exports["./jsx-dev-runtime"] = "./dist/jsx-runtime.js";
                    }

                    pkgJson = new OrderedDictionary()
                    {
                        ["name"] = pkgId,
                        ["type"] = "module",
                        ["main"] = "dist/index.js",
                        ["import"] = "dist/index.js",
                        ["types"] = "dist/index.d.ts",
                        ["exports"] = exports
                    };
                }

                var jsonBuilder = new JsonBuilder(true);
                jsonBuilder.AppendDictionary(pkgJson);
                var pkgContent = jsonBuilder.ToString().TrimEnd();

                if (!File.Exists(pkgFile) || File.ReadAllText(pkgFile) != pkgContent)
                    File.WriteAllText(pkgFile, pkgContent);

                newDeps[pkgId] = "./node_modules/.dotnet/" + pkgFolder.Replace("\"", "\\\"");
            }

            if (PatchDependencies != "false")
            {
                var pkgProj = "package.json";
                if (!File.Exists(pkgProj))
                {
                    Log.LogWarning("Can't find package.json");
                    return Success;
                }
                var oldContent = File.ReadAllText(pkgProj).Replace("\r", "").Trim();
                var newJson = new JsonParser(oldContent).ParseObject();
                if (newJson != null && newJson.Contains("dependencies"))
                {
                    var oldDeps = (IDictionary)newJson["dependencies"];
                    bool changed = false;
                    foreach (DictionaryEntry kvp in oldDeps)
                    {
                        var name = kvp.Key.ToString();
                        var value = kvp.Value?.ToString();

                        if (value == null || !newDeps.ContainsKey(name) ||
                            !value.StartsWith("file:./node_modules/.dotnet/") ||
                            !value.StartsWith("./node_modules/.dotnet/"))
                        {
                            newDeps[name] = value;
                            continue;
                        }
                    }
                    if (changed)
                    {
                        var jb = new JsonBuilder(true);
                        jb.AppendDictionary(newJson);
                        var updatedContent = jb.ToString().TrimEnd();
                        File.WriteAllText(pkgProj, updatedContent);
                    }

                    newJson["dependencies"] = newDeps;
                    var builder = new JsonBuilder(true);
                    builder.AppendDictionary(newJson);
                    var newContent = builder.ToString().TrimEnd();
                    if (oldContent != newContent)
                        File.WriteAllBytes(pkgProj, Encoding.UTF8.GetBytes(newContent));
                }
            }
        }
        catch (Exception ex)
        {
            Log.LogWarning("Error during RestoreNodeTypesTask: " + ex.ToString());
        }

        return Success;
    }

    // adapted from https://github.com/gering/Tiny-JSON (https://github.com/gering/Tiny-JSON/blob/master/LICENSE)
    public class JsonParser : IDisposable
    {
        enum Token { None, CurlyOpen, CurlyClose, SquareOpen, SquareClose, Colon, Comma, String, Number, BoolOrNull };
        StringReader json;
        readonly StringBuilder sb = new StringBuilder();
        public static object ParseValue(string jsonString) { using (var parser = new JsonParser(jsonString)) return parser.ParseValue(); }
        internal JsonParser(string jsonString) { json = new StringReader(jsonString); }
        public void Dispose() { json.Dispose(); json = null; }

        bool EndReached() { return json.Peek() == -1; }
        bool PeekWordbreak() { char c = PeekChar(); return c == ' ' || c == ',' || c == ':' || c == '\"' || c == '{' || c == '}' || c == '[' || c == ']' || c == '\t' || c == '\n' || c == '\r'; }
        bool PeekWhitespace() { char c = PeekChar(); return c == ' ' || c == '\t' || c == '\n' || c == '\r'; }
        char PeekChar() { return Convert.ToChar(json.Peek()); }
        char ReadChar() { return Convert.ToChar(json.Read()); }
        string ReadWord() { sb.Clear(); while (!PeekWordbreak() && !EndReached()) { sb.Append(ReadChar()); } return EndReached() ? null : sb.ToString(); }
        void EatWhitespace() { while (PeekWhitespace()) { json.Read(); } }
        Token PeekToken()
        {
            EatWhitespace(); if (EndReached()) return Token.None;
            switch (PeekChar())
            {
                case '{': return Token.CurlyOpen;
                case '}': return Token.CurlyClose;
                case '[': return Token.SquareOpen;
                case ']': return Token.SquareClose;
                case ',': return Token.Comma;
                case '"': return Token.String;
                case ':': return Token.Colon;
                case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '-': return Token.Number;
                case 't': case 'f': case 'n': return Token.BoolOrNull;
                default: return Token.None;
            }
        }

        object ParseBoolOrNull()
        {
            if (PeekToken() != Token.BoolOrNull) return null; //Console.WriteLine("Unexpected bool token: " + PeekToken());
            string boolValue = ReadWord();
            if (boolValue == "true") return true;
            if (boolValue == "false") return false;
            if (boolValue == "null") return null;
            //Console.WriteLine("Unexpected bool value: " + boolValue);
            return null;
        }

        object ParseNumber()
        {
            if (PeekToken() != Token.Number) return null; //Console.WriteLine("Unexpected number token: " + PeekToken());
            string number = ReadWord();
            if (number.Contains(".")) { if (double.TryParse(number, NumberStyles.Float, CultureInfo.InvariantCulture, out double parsed)) return parsed; }
            else if (long.TryParse(number, out long parsed)) return parsed;
            return null; //Console.WriteLine("Unexpected number value: " + number);
        }

        string ParseString()
        {
            if (PeekToken() != Token.String) return null; // Console.WriteLine("Unexpected string token: " + PeekToken());
            ReadChar();
            sb.Clear();
            char c;
            while (true)
            {
                if (EndReached()) return null;
                switch (c = ReadChar())
                {
                    case '"': return sb.ToString();
                    case '\\':
                        if (EndReached()) return null;
                        switch (c = ReadChar())
                        {
                            case '"': case '\\': case '/': sb.Append(c); break;
                            case 'b': sb.Append('\b'); break;
                            case 'f': sb.Append('\f'); break;
                            case 'n': sb.Append('\n'); break;
                            case 'r': sb.Append('\r'); break;
                            case 't': sb.Append('\t'); break;
                            case 'u': var hex = string.Concat(ReadChar(), ReadChar(), ReadChar(), ReadChar()); sb.Append((char)Convert.ToInt32(hex, 16)); break;
                        }
                        break;
                    default: sb.Append(c); break;
                }
            }
        }

        public OrderedDictionary ParseObject()
        {
            if (PeekToken() != Token.CurlyOpen) return null; // Console.WriteLine("Unexpected object token: " + PeekToken())
            json.Read();
            OrderedDictionary table = new OrderedDictionary();
            while (true) switch (PeekToken())
                {
                    case Token.None: return null;
                    case Token.Comma: json.Read(); continue;
                    case Token.CurlyClose: json.Read(); return table;
                    default:
                        string name = ParseString();
                        if (string.IsNullOrEmpty(name)) return null;
                        if (PeekToken() != Token.Colon) return null;
                        json.Read();
                        table[name] = ParseValue();
                        break;
                }
        }

        List<object> ParseArray()
        {
            if (PeekToken() != Token.SquareOpen) return null; // Console.WriteLine("Unexpected array token: " + PeekToken());
            json.Read(); // ditch opening brace
            List<object> array = new List<object>();
            while (true) switch (PeekToken())
                {
                    case Token.None: return null;
                    case Token.Comma: json.Read(); continue;
                    case Token.SquareClose: json.Read(); return array;
                    default: array.Add(ParseValue()); break;
                }
        }

        object ParseValue()
        {
            switch (PeekToken())
            {
                case Token.String: return ParseString();
                case Token.Number: return ParseNumber();
                case Token.BoolOrNull: return ParseBoolOrNull();
                case Token.CurlyOpen: return ParseObject();
                case Token.SquareOpen: return ParseArray();
                default: return null; // Console.WriteLine("Unexpected value token: " + PeekToken());
            }
        }
    }

    public class JsonBuilder
    {
        readonly StringBuilder sb = new StringBuilder();
        readonly bool pretty;
        int level;
        bool pendingIndent;

        public JsonBuilder(bool pretty = true) { this.pretty = pretty; }

        public void Indent() { if (pendingIndent) { for (int i = 0; i < level; i++) sb.Append("  "); pendingIndent = false; } }
        public void NewLine() { if (pretty) { sb.Append('\n'); pendingIndent = level > 0; } }
        public void BeginObject() { level++; sb.Append('{'); NewLine(); }
        public void EndObject() { NewLine(); level--; Indent(); sb.Append('}'); }
        public void BeginArray() { level++; sb.Append('['); NewLine(); }
        public void EndArray() { Indent(); sb.Append(']'); level--; NewLine(); }
        public void Seperator() { Indent(); sb.Append(','); if (pretty) sb.Append('\n'); if (pretty) pendingIndent = true; }
        public void AppendNull() { Indent(); sb.Append("null"); }
        public void AppendBool(bool b) { Indent(); sb.Append(b ? "true" : "false"); }

        internal static bool IsFloatingPoint(Type type)
        {
            if (type.IsEnum) return false;
            switch (Type.GetTypeCode(type))
            {
                case TypeCode.Decimal: case TypeCode.Double: case TypeCode.Single: return true;
                case TypeCode.Object: Type underlyingType = Nullable.GetUnderlyingType(type); return underlyingType != null && IsFloatingPoint(underlyingType);
                default: return false;
            }
        }

        public void AppendNumber(object number)
        {
            Indent();
            if (number == null) { AppendNull(); return; }
            string numberString = Convert.ToString(number, CultureInfo.InvariantCulture);
            if (IsFloatingPoint(number.GetType()) && !numberString.Contains(".")) numberString += ".0";
            sb.Append(numberString);
        }

        public void AppendString(string str)
        {
            if (str == null) { AppendNull(); return; }
            Indent();
            sb.Append('\"');
            foreach (var c in str) switch (c)
                {
                    case '"': sb.Append("\\\""); break;
                    case '\\': sb.Append("\\\\"); break;
                    case '\b': sb.Append("\\b"); break;
                    case '\f': sb.Append("\\f"); break;
                    case '\n': sb.Append("\\n"); break;
                    case '\r': sb.Append("\\r"); break;
                    case '\t': sb.Append("\\t"); break;
                    default: int codepoint = Convert.ToInt32(c); if (pretty || (codepoint >= 32 && codepoint <= 126)) sb.Append(c); else sb.Append("\\u" + Convert.ToString(codepoint, 16).PadLeft(4, '0')); break;
                }
            sb.Append('\"');
        }

        public void AppendArray(IEnumerable enumerable)
        {
            if (enumerable == null) { AppendNull(); return; }
            Indent();
            BeginArray(); bool first = true; foreach (var item in enumerable) { if (first) first = false; else Seperator(); AppendValue(item); }
            EndArray();
        }

        public void AppendDictionary(IDictionary dict)
        {
            if (dict == null) { AppendNull(); return; }
            Indent();
            BeginObject();
            bool first = true;
            foreach (DictionaryEntry entry in dict)
            {
                if (first) first = false; else Seperator();
                AppendString(entry.Key.ToString());
                sb.Append(pretty ? ": " : ":");
                AppendValue(entry.Value);
            }
            EndObject();
        }

        public void AppendValue(object value)
        {
            Indent();
            if (value == null) AppendNull();
            else if (value is bool v) AppendBool(v);
            else if (value is string s) AppendString(s);
            else if (value is char) AppendString("" + value);
            else if (IsEnum(value)) AppendNumber((int)value);
            else if (IsNumber(value)) AppendNumber(value);
            else if (value is IDictionary dict) AppendDictionary(dict);
            else if (value is IEnumerable en) AppendArray(en);
            else { }//Console.WriteLine("Type " + value.GetType() + " not supported!");
        }

        public void AppendName(string name) { AppendString(name); sb.Append(pretty ? " : " : ":"); }
        public static bool IsNumeric(Type type)
        {
            if (type.IsEnum) return false;
            switch (Type.GetTypeCode(type))
            {
                case TypeCode.Byte: case TypeCode.SByte: case TypeCode.UInt16: case TypeCode.UInt32: case TypeCode.UInt64: case TypeCode.Int16: case TypeCode.Int32: case TypeCode.Int64: case TypeCode.Decimal: case TypeCode.Double: case TypeCode.Single: return true;
                case TypeCode.Object: Type underlyingType = Nullable.GetUnderlyingType(type); return underlyingType != null && IsNumeric(underlyingType);
                default: return false;
            }
        }
        internal static bool IsNumber(object value) { return value != null && IsNumeric(value.GetType()); }
        internal static bool IsEnum(object value) { return value != null && value.GetType().IsEnum; }
        public override string ToString() { return sb.ToString(); }
    }
}

#if IsExternalTestProject
namespace Microsoft.Build.Utilities
{
    public class Task()
    {
        public virtual bool Execute() { return true; }
        public static class Log
        {
            public static void LogWarning(string text) {}
        }
    }
}
#endif
